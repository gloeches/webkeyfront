
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Structured Frontend Logging for Angular Applications</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 900px;
            margin: 20px auto;
            padding: 0 20px;
        }
        h1, h2, h3, h4 {
            color: #0d47a1;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 10px;
        }
        h4 { 
            border-bottom: 1px solid #e0e0e0;
        }
        pre {
            background-color: #f4f4f4;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            border: 1px solid #ddd;
        }
        code {
            font-family: "Courier New", Courier, monospace;
        }
        .step {
            background-color: #f9f9f9;
            border: 1px solid #eee;
            border-left: 5px solid #0d47a1;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 5px;
        }
        .filename {
            font-weight: bold;
            font-family: monospace;
            color: #c62828;
            display: block;
            margin-bottom: 10px;
        }
        .note {
            background-color: #e3f2fd;
            border-left-color: #2196f3;
        }
    </style>
</head>
<body>

    <h1>Structured Frontend Logging for Angular Applications</h1>

    <div class="step">
        <h2>The Core Challenge: Browser Security</h2>
        <p>A web application running in a user's browser (like an Angular app) is heavily sandboxed for security reasons. It has <strong>no direct access</strong> to the user's local filesystem. This means your Angular code cannot directly create or write to a log file on the server or the client machine.</p>
        <p>The standard solution is to send log data from the frontend to a backend server, which can then process and store it.</p>
    </div>

    <div class="step">
        <h2>The Best Practice: A Backend Logging Endpoint</h2>
        <p>This architecture is the industry standard for handling frontend logs:</p>
        <pre>
+-----------------+      +----------------------+      +------------------------+      +-------------+
| Angular App     |----->|  HTTP POST Request   |----->| .NET API Endpoint      |----->|  Log File   |
| (LoggingService)|      | (sends log data)     |      | (/api/v1/logs)         |      | (on server) |
+-----------------+      +----------------------+      +------------------------+      +-------------+
        </pre>
    </div>

    <div class="step">
        <h3>Implementation Step 1: The Angular Logging Service</h3>
        <p>This service will be your replacement for <code>console.log</code>.</p>
        <span class="filename">src/app/services/logging.service.ts</span>
        <pre><code>import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { ConstantsService } from '../shared/header/constants.service';

// Defines the structure of a log entry
export interface LogEntry {
  level: LogLevel;
  message: string;
  timestamp: Date;
  additionalInfo?: any;
}

export enum LogLevel {
  Info = 'INFO',
  Warning = 'WARN',
  Error = 'ERROR',
  Debug = 'DEBUG'
}

@Injectable({
  providedIn: 'root'
})
export class LoggingService {

  private loggingUrl: string;

  constructor(private http: HttpClient, private constants: ConstantsService) {
    // Construct the full URL to the logging endpoint once.
    this.loggingUrl = `${this.constants.rootUrl}/api/v1/logs`;
  }

  info(message: string, additionalInfo?: any) {
    this.log({ level: LogLevel.Info, message, timestamp: new Date(), additionalInfo });
  }

  warn(message: string, additionalInfo?: any) {
    this.log({ level: LogLevel.Warning, message, timestamp: new Date(), additionalInfo });
  }

  error(message: string, additionalInfo?: any) {
    this.log({ level: LogLevel.Error, message, timestamp: new Date(), additionalInfo });
  }

  private log(entry: LogEntry) {
    // During development, it's helpful to still see logs in the browser console.
    console.log(entry);

    // Send the log entry to the backend API.
    // The .subscribe() is crucial because HttpClient requests are cold (do not run) until subscribed.
    this.http.post(this.loggingUrl, entry).subscribe();
  }
}</code></pre>
    </div>

    <div class="step">
        <h3>Implementation Step 2: Using the Service in a Component</h3>
        <p>Inject your new <code>LoggingService</code> into any component or service where you need to log information.</p>
        <span class="filename">Example Component</span>
        <pre><code>import { Component } from '@angular/core';
import { LoggingService } from '../services/logging.service';

@Component({
  selector: 'app-some-component',
  template: `&lt;button (click)="doSomething()"&gt;Do Something&lt;/button&gt;`
})
export class SomeComponent {

  constructor(private logger: LoggingService) {}

  doSomething() {
    this.logger.info('User clicked the "Do Something" button.');
    try {
      // ... some logic that might fail
      throw new Error('Something went wrong!');
    } catch (error) {
      // You can pass the entire error object as additional info.
      this.logger.error('An error occurred while doing something.', error);
    }
  }
}</code></pre>
    </div>

    <div class="step">
        <h3>Implementation Step 3: The .NET Backend (Standard Controller Structure)</h3>
        <p>This approach separates concerns into different files (Models, Controllers, and Program.cs), which is common for larger applications.</p>
        
        <h4>Recommended Project Structure</h4>
        <p>After creating the project and adding the new files, your API project folder should look like this:</p>
        <pre><code>/LoggingApi
├── Controllers/
│   └── LogsController.cs
├── Models/
│   └── LogEntry.cs
├── Properties/
│   └── launchSettings.json
├── logs/
│   └── frontend-logs-20250915.txt (auto-generated by Serilog)
├── appsettings.Development.json
├── appsettings.json
├── Dockerfile
├── LoggingApi.csproj
├── Program.cs
└── ... (other files like .sln)
</code></pre>

        <h4>Instructions:</h4>
        <ol>
            <li>Create a new .NET Web API project (e.g., <code>dotnet new webapi -n LoggingApi</code>).</li>
            <li>Add the required Serilog NuGet packages:</li>
        </ol>
        <pre><code>dotnet add package Serilog.AspNetCore
dotnet add package Serilog.Sinks.File</code></pre>
        <li>Create the following files and folders as shown in the structure above.</li>

        <hr/>

        <h4>1. The LogEntry Model</h4>
        <p>Create a `Models` folder and add this file. This record defines the shape of the data sent from Angular.</p>
        <span class="filename">Models/LogEntry.cs</span>
        <pre><code>using System.Text.Json;

namespace YourApi.Models;

public record LogEntry(string Level, string Message, DateTime Timestamp, JsonElement AdditionalInfo);
</code></pre>

        <h4>2. The Logs Controller</h4>
        <p>Create a `Controllers` folder and add this file. This class handles the incoming HTTP request.</p>
        <span class="filename">Controllers/LogsController.cs</span>
        <pre><code>using Microsoft.AspNetCore.Mvc;
using YourApi.Models; // Import the LogEntry model

namespace YourApi.Controllers;

[ApiController]
[Route("api/v1/logs")] // Defines the URL for this controller
public class LogsController : ControllerBase
{
    private readonly ILogger&lt;LogsController&gt; _logger;

    // The logger is injected via the constructor
    public LogsController(ILogger&lt;LogsController&gt; logger)
    {
        _logger = logger;
    }

    [HttpPost]
    public IActionResult PostLog([FromBody] LogEntry logEntry)
    {
        var serilogLevel = logEntry.Level.ToUpper() switch
        {
            "INFO" => LogLevel.Information,
            "WARN" => LogLevel.Warning,
            "ERROR" => LogLevel.Error,
            "DEBUG" => LogLevel.Debug,
            _ => LogLevel.Information
        };

        _logger.Log(serilogLevel, "[Frontend] {Message} -- Additional Info: {Info}", 
            logEntry.Message, 
            logEntry.AdditionalInfo.ToString()); // Convert JsonElement to string for logging

        return Ok();
    }
}
</code></pre>

        <h4>3. The Main Program File</h4>
        <p>Finally, your <code>Program.cs</code> is now much simpler. It is only responsible for configuration and wiring everything together.</p>
        <span class="filename">Program.cs</span>
        <pre><code>using Serilog;

// 1. SERILOG CONFIGURATION
Log.Logger = new LoggerConfiguration()
    .WriteTo.Console()
    .WriteTo.File("logs/frontend-logs.txt", rollingInterval: RollingInterval.Day)
    .CreateBootstrapLogger();

var builder = WebApplication.CreateBuilder(args);

builder.Host.UseSerilog();

// 2. REGISTER SERVICES

// This service registers your controllers with the application.
builder.Services.AddControllers();

// Add Swagger for API testing (optional but recommended).
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

// 3. CORS POLICY
var angularAppOrigin = "http://localhost:4200";
builder.Services.AddCors(options =>
{
    options.AddPolicy(name: "AllowAngularApp",
                      policy =>
                      {
                          policy.WithOrigins(angularAppOrigin)
                                .AllowAnyHeader()
                                .AllowAnyMethod();
                      });
});

var app = builder.Build();

// 4. CONFIGURE HTTP PIPELINE

if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

app.UseCors("AllowAngularApp");

app.UseHttpsRedirection();

app.UseAuthorization();

// This maps the routes defined in your Controller attributes.
app.MapControllers();

app.Run();
</code></pre>
    </div>

    <div class="step note">
        <h3>Implementation Step 4: Dockerizing the .NET Logging API</h3>
        <p>Containerizing the backend API ensures it runs in a consistent, isolated environment. You will need to create a <code>Dockerfile</code> in the root of your new .NET API project.</p>

        <h4>1. The Dockerfile for .NET</h4>
        <p>This Dockerfile uses a multi-stage build, which is a best practice. It builds the app in a temporary SDK image and then copies only the necessary published files into a smaller, final runtime image.</p>
        <span class="filename">Dockerfile</span>
        <pre><code># Stage 1: Build the application
FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build
WORKDIR /src

# Copy the project file and restore dependencies first to leverage Docker layer caching
COPY ["LoggingApi.csproj", "."]
RUN dotnet restore "./LoggingApi.csproj"

# Copy the rest of the source code and build the release version
COPY . .
RUN dotnet publish "LoggingApi.csproj" -c Release -o /app/publish --no-restore

# Stage 2: Create the final, smaller runtime image
FROM mcr.microsoft.com/dotnet/aspnet:8.0 AS final
WORKDIR /app

# Copy the published output from the build stage
COPY --from=build /app/publish .

# The entrypoint command to run the API
ENTRYPOINT ["dotnet", "LoggingApi.dll"]
</code></pre>
        <p><em>Note: Replace `LoggingApi.csproj` and `LoggingApi.dll` with the actual name of your .NET project if it's different.</em></p>

        <h4>2. Building the API Image</h4>
        <p>From the root of your .NET API project, run the build command:</p>
        <pre><code>docker build -t logging-api .</code></pre>

        <h4>3. Running the API Container</h4>
        <p>This command runs the container and introduces a **volume mount** to ensure your log files are saved on your host machine.</p>
        <pre><code>docker run --name logging-api-container -d -p 8081:80 -v C:\Users\YourUser\Desktop\api-logs:/app/logs logging-api</code></pre>
        <ul>
            <li><strong><code>-p 8081:80</code></strong>: Maps port 8081 on your host machine to port 80 inside the container (where the .NET app listens by default).</li>
            <li><strong><code>-v C:\...\api-logs:/app/logs</code></strong>: This is the volume mount. It links a folder on your computer to the <code>/app/logs</code> folder inside the container (where Serilog is configured to write). This is **critical** for making sure your logs persist even if the container is deleted.</li>
            <li><strong>Important:</strong> You must replace <code>C:\Users\YourUser\Desktop\api-logs</code> with an actual, absolute path to a folder on your machine.</li>
        </ul>

        <h4>Connecting the Frontend</h4>
        <p>Now that your API is running on port 8081, you must tell your Angular application where to find it. Update the <code>rootUrl</code> in your Angular project's configuration to point to the new containerized API endpoint:</p>
        <ul>
            <li>For local development: Change <code>src/assets/config/config.json</code> to use <code>"rootUrl": "http://localhost:8081"</code>.</li>
            <li>For your Dockerized frontend: When you run it, use <code>-e ROOT_URL="http://localhost:8081"</code> in the `docker run` command.</li>
        </ul>
    </div>

    <div class="step">
        <h3>Step 5: Alternative - Third-Party Logging Platforms</h3>
        <p>For production applications, consider using cloud-based logging services like Sentry, LogRocket, or Datadog. They provide powerful UIs for searching and analyzing logs without needing to manage your own logging backend.</p>
    </div>

</body>
</html>
